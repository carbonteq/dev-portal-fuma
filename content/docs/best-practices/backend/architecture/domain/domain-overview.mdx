---
title: Overview
---
import { File, Folder, Files } from 'fumadocs-ui/components/files';
import { User, Gamepad, Tools, Filter } from 'iconoir-react';
import { BiLogoTypescript } from 'react-icons/bi';
import { ScrollyCoding } from '@/components/ui/ScrollyCoding';

## Code Organization

The domain layer is organized by business entities and utilities, following domain-driven design principles:

<Files>
  <Folder name="domain" defaultOpen>    
    <Folder name="user" defaultOpen icon={<User />}>
      <File name="user.entity.ts" icon={<BiLogoTypescript />} />
      <File name="user.guards.ts" icon={<BiLogoTypescript />} />
      <File name="user.error.ts" icon={<BiLogoTypescript />} />
      <File name="host.entity.ts" icon={<BiLogoTypescript />} />
      <File name="address.vo.ts" icon={<BiLogoTypescript />} />
    </Folder>
    <Folder name="game" icon={<Gamepad />}>
      <File name="game.entity.ts" icon={<BiLogoTypescript />} />
      <File name="game.guards.ts" icon={<BiLogoTypescript />} />
      <File name="game.error.ts" icon={<BiLogoTypescript />} />
    </Folder>
    <Folder name="utils" defaultOpen icon={<Tools />}>
      <File name="base.entity.ts" icon={<BiLogoTypescript />} />
      <File name="base.repository.ts" icon={<BiLogoTypescript />} />
      <File name="base.errors.ts" icon={<BiLogoTypescript />} />
      <File name="refined.types.ts" icon={<BiLogoTypescript />} />
      <File name="validation.utils.ts" icon={<BiLogoTypescript />} />
      <File name="pagination.ts" icon={<BiLogoTypescript />} />
      <File name="index.ts" icon={<BiLogoTypescript />} />
    </Folder>
    <Folder name="refined" icon={<Filter />}>
      <File name="[custom-refined-type].ts" icon={<BiLogoTypescript />} />
      <File name="index.ts" icon={<BiLogoTypescript />} />
    </Folder>
  </Folder>
</Files>

## Entity Evolution: Building a Robust Host Entity

This section demonstrates the step-by-step evolution of a Host entity from basic TypeScript patterns to a robust, type-safe implementation using functional programming principles.

<ScrollyCoding>

## !!steps Foundation - Interface and Basic Class

Start with the fundamental building blocks - create the IHost interface that extends the base IEntity and establish the Host class structure.

```typescript !
import { BaseEntity, IEntity } from "@domain/utils/base.entity";
import { UUID } from "@domain/utils/refined.types";
import { Address } from "./address.vo";
import { SocialLinks } from "./socialLinks.vo";

// !mark(1:7) rgb(34, 197, 94)
interface IHost extends IEntity {
  readonly userId: UUID;
  readonly dob: Date;
  readonly phoneNumber: number;
  readonly profileImage: string;
}

// !mark(1:3) rgb(34, 197, 94)
export class Host extends BaseEntity implements IHost {
  // Properties will be added in the next step
}
```

## !!steps Adding Properties with Proper Types

Add class properties with appropriate types, establishing the structure for our Host entity.

```typescript !
// !collapse(1:5) collapsed
// Collapsed imports
import { BaseEntity, IEntity } from "@domain/utils/base.entity";
import { UUID } from "@domain/utils/refined.types";
import { Address } from "./address.vo";
import { SocialLinks } from "./socialLinks.vo";


// !collapse(1:7) collapsed
// Collapsed Domain interface definition
interface IHost extends IEntity {
  readonly userId: UUID;
  readonly dob: Date;
  readonly phoneNumber: number;
  readonly profileImage: string;
}

export class Host extends BaseEntity implements IHost {
  // !mark(1:6) rgb(34, 197, 94)
  userId: UUID;
  dob: Date;
  phoneNumber: number;
  address: Address;
  socialLinks: SocialLinks;
  profileImage: string;
}
```

## !!steps Making Properties Optional with Option&lt;T&gt;

Refactor properties to use `Option<T>` for optional fields, showing the shift from nullable types to functional programming patterns for better type safety.

```typescript !
import { BaseEntity, IEntity } from "@domain/utils/base.entity";
import { UUID } from "@domain/utils/refined.types";
import { Address } from "./address.vo";
import { SocialLinks } from "./socialLinks.vo";
// !mark(1:1) rgb(34, 197, 94)
import { Option as O } from "effect";


interface IHost extends IEntity {
  readonly userId: UUID;
  // !mark(1:3) rgb(34, 197, 94)
  readonly dob: O.Option<Date>;
  readonly phoneNumber: O.Option<number>;
  readonly profileImage: O.Option<string>;
}

export class Host extends BaseEntity implements IHost {
  userId: UUID;
  // !mark(1:3) rgb(34, 197, 94)
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;
}

// !info[/O\.Option<T>/] Explicit handling of optional vs required fields
// !callout[/Option<T>/] Type safety for values that may or may not exist
```

## !!steps Empty Constructor Setup

Add a basic constructor structure that accepts data and value objects, setting up the foundation for incremental implementation.

```typescript !
// !collapse(1:6) collapsed
// Collapsed imports
import { BaseEntity, IEntity } from "@domain/utils/base.entity";
import { UUID } from "@domain/utils/refined.types";
import { Address } from "./address.vo";
import { SocialLinks } from "./socialLinks.vo";
import { Option as O } from "effect";


// !collapse(1:7) collapsed
// Collapsed IHost
interface IHost extends IEntity {
  readonly userId: UUID;
  readonly dob: Date;  
  readonly phoneNumber: number;
  readonly profileImage: string;
}

export class Host extends BaseEntity implements IHost {
  // !collapse(1:7) collapsed
  // Collapsed class properties
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;
  
  // !mark(1:4) rgb(34, 197, 94)
  constructor(data: unknown, address: Address, socialLinks: SocialLinks) {
    // !callout[/super\(\)/] Always call parent constructor for BaseEntity
    super(); // Initialize BaseEntity
    // Constructor implementation will be added progressively
  }
}


```

## !!steps Adding Computed Properties

Add getter methods for computed properties while collapsing the main properties to focus on business logic encapsulation.

```typescript !
// !collapse(1:6) collapsed
// Collapsed imports
import { BaseEntity, IEntity } from "@domain/utils/base.entity";
import { UUID } from "@domain/utils/refined.types";
import { Address } from "./address.vo";
import { SocialLinks } from "./socialLinks.vo";
import { Option as O } from "effect";

// !collapse(1:7) collapsed
// Collapsed IHost
interface IHost extends IEntity {
  readonly userId: UUID;
  readonly dob: Date;  
  readonly phoneNumber: number;
  readonly profileImage: string;
}

export class Host extends BaseEntity implements IHost {
  // !collapse(1:7) collapsed
  // Collapsed class properties
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;
  
  // Constructor from previous step
  // !collapse(1:4) collapsed
  constructor(data: unknown, address: Address, socialLinks: SocialLinks) {
    super();
    // Constructor implementation pending
  }
  
  // !mark(1:5) rgb(34, 197, 94)
  get hasCompleteProfile(): boolean {
    return O.isSome(this.dob) && 
           O.isSome(this.phoneNumber) && 
           O.isSome(this.profileImage);
  }
}

```

## !!steps Creating SerializedHost Type

Introduce the concept of serialized types for data transfer, establishing the contract between internal representation and external APIs.

```typescript !
// !collapse(1:6) collapsed
// Collapsed imports
import { BaseEntity, IEntity } from "@domain/utils/base.entity";
import { UUID } from "@domain/utils/refined.types";
import { Address } from "./address.vo";
import { SocialLinks } from "./socialLinks.vo";
import { Option as O } from "effect";

// !collapse(1:7) collapsed
// Collapsed IHost
interface IHost extends IEntity {
  readonly userId: UUID;
  readonly dob: O.Option<Date>;
  readonly phoneNumber: O.Option<number>;
  readonly profileImage: O.Option<string>;
}

// !mark(1:14) rgb(34, 197, 94)
type SerializedHost = { // !info[/SerializedHost/] Separate type for data transfer and persistence
  // Base entity fields
  id: string;
  createdAt: string;
  updatedAt: string;
  // Host-specific fields
  userId: string;
  dob: Date | null | undefined; // !warning[/Date \| null \| undefined/] Union types for optional fields are verbose
  phoneNumber: number | null | undefined;
  profileImage: string | null | undefined;
  // Value objects (simplified for now)
  address: unknown;
  socialLinks: unknown;
}

export class Host extends BaseEntity implements IHost {
  // !collapse(1:7) collapsed
  // Collapsed class properties
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;
  
  // Constructor from previous step
  // !collapse(1:4) collapsed
  constructor(data: unknown, address: Address, socialLinks: SocialLinks) {
    super();
    // Constructor implementation pending
  }
  
  // !collapse(1:5) collapsed
  get hasCompleteProfile(): boolean {
    return O.isSome(this.dob) && 
           O.isSome(this.phoneNumber) && 
           O.isSome(this.profileImage);
  }
}



```

## !!steps Introducing Maybe&lt;T&gt; Utility Type

Refactor the serialized type to use the flexible `Maybe<T>` utility that can handle multiple input formats for better API flexibility.

```typescript !
// !collapse(1:5) collapsed
// Collapsed imports
import { BaseEntity, IEntity } from "@domain/utils/base.entity";
import { UUID } from "@domain/utils/refined.types";
import { Address } from "./address.vo";
import { SocialLinks } from "./socialLinks.vo";
import { Option as O } from "effect";

// !mark(1:3) rgb(34, 197, 94)
// Flexible type for serialization that accepts multiple input formats
type Maybe<T> = T | O.Option<T> | null | undefined; // !callout[/Maybe<T>/] Flexible input handling for different data sources

// !collapse(1:7) collapsed
// Collapsed IHost
interface IHost extends IEntity {
  readonly userId: UUID;
  readonly dob: O.Option<Date>;
  readonly phoneNumber: O.Option<number>;
  readonly profileImage: O.Option<string>;
}

// !collapse(1:15) collapsed
// Collapsed Host class implementation
export class Host extends BaseEntity implements IHost {
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;
  
  constructor(data: unknown, address: Address, socialLinks: SocialLinks) {
    super();
    // Constructor implementation pending
  }
  
  get hasCompleteProfile(): boolean {
    return O.isSome(this.dob) && O.isSome(this.phoneNumber) && O.isSome(this.profileImage);
  }
}

// !mark(1:12) rgb(234, 179, 8)
type SerializedHost = {
  // Base entity fields
  id: string;
  createdAt: string;
  updatedAt: string;
  // Host-specific fields  
  userId: string;
  dob: Maybe<Date>; // !info[/Maybe<Date>/] Accepts T | Option<T> | null | undefined
  phoneNumber: Maybe<number>;
  profileImage: Maybe<string>;
  // Value objects
  address: unknown;
  socialLinks: unknown;
}
```

## !!steps Implementing Constructor with Data Handling

Complete the constructor implementation using the serialized type with proper data validation and transformation using utility functions.

```typescript !
// !collapse(1:5) collapsed
// Collapsed imports
import { BaseEntity, IEntity } from "@domain/utils/base.entity";
import { UUID } from "@domain/utils/refined.types";
import { Address } from "./address.vo";
import { SocialLinks } from "./socialLinks.vo";
import { Option as O } from "effect";

// !collapse(1:3) collapsed
// Collapsed Maybe type definition
type Maybe<T> = T | O.Option<T> | null | undefined;

// !collapse(1:12) collapsed
// Collapsed SerializedHost type
type SerializedHost = {
  id: string;
  createdAt: string;
  updatedAt: string;
  userId: string;
  dob: Maybe<Date>;
  phoneNumber: Maybe<number>;
  profileImage: Maybe<string>;
  address: unknown;
  socialLinks: unknown;
}

// !collapse(1:7) collapsed
// Collapsed IHost
interface IHost extends IEntity {
  readonly userId: UUID;
  readonly dob: O.Option<Date>;
  readonly phoneNumber: O.Option<number>;
  readonly profileImage: O.Option<string>;
}

export class Host extends BaseEntity implements IHost {
  // !collapse(1:6) collapsed
  // Collapsed class properties
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;
  
  // !mark(1:14) rgb(34, 197, 94)
  constructor(data: SerializedHost, address: Address, socialLinks: SocialLinks) {
    super(); // !callout[/super\(\)/] Always call parent constructor for BaseEntity
    // Initialize base entity fields from serialized data
    this._fromSerialized({ // !info[/this\._fromSerialized/] BaseEntity method for common fields
      id: data.id,
      createdAt: data.createdAt,
      updatedAt: data.updatedAt
    });
    
    // Transform and assign host-specific fields
    this.userId = data.userId as UUID;
    this.dob = normalizeMaybe(data.dob); // !callout[/normalizeMaybe/] Converts Maybe<T> to consistent Option<T>
    this.phoneNumber = normalizeMaybe(data.phoneNumber);
    this.profileImage = normalizeMaybe(data.profileImage);
    this.address = address;
    this.socialLinks = socialLinks;
  }
}
```

## !!steps Adding normalizeMaybe Utility

Show the implementation of the `normalizeMaybe` utility function that handles the flexible Maybe&lt;T&gt; to Option&lt;T&gt; conversion safely.

```typescript !
// !collapse(1:5) collapsed
// Collapsed imports
import { BaseEntity, IEntity } from "@domain/utils/base.entity";
import { UUID } from "@domain/utils/refined.types";
import { Address } from "./address.vo";
import { SocialLinks } from "./socialLinks.vo";
import { Option as O } from "effect";

// !collapse(1:3) collapsed
// Collapsed Maybe type definition
type Maybe<T> = T | O.Option<T> | null | undefined;

// !mark(1:11) rgb(34, 197, 94)
/**
 * Normalize Maybe<T> to Option<T> - use in entity constructors
 */
const normalizeMaybe = <T>(value: Maybe<T>): O.Option<T> => {
  if (value === null || value === undefined) {
    return O.none(); // !info[/O\.none\(\)/] Returns empty Option for null/undefined
  }
  if (O.isOption(value)) { // !warning[/O\.isOption\(value\)/] Type guard to check if value is already an Option
    return value;
  }
  return O.some(value); // !callout[/normalizeMaybe/] Handles any input format gracefully
};

// !collapse(1:25) collapsed
// Collapsed previous definitions
interface IHost extends IEntity {
  readonly userId: UUID;
  readonly dob: O.Option<Date>;
  readonly phoneNumber: O.Option<number>;
  readonly profileImage: O.Option<string>;
}

type SerializedHost = {
  id: string; createdAt: string; updatedAt: string;
  userId: string; dob: Maybe<Date>; phoneNumber: Maybe<number>;
  profileImage: Maybe<string>; address: unknown; socialLinks: unknown;
}

export class Host extends BaseEntity implements IHost {
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;
  
  constructor(data: SerializedHost, address: Address, socialLinks: SocialLinks) {
    super();
    this._fromSerialized({id: data.id, createdAt: data.createdAt, updatedAt: data.updatedAt});
    this.userId = data.userId as UUID;
    this.dob = normalizeMaybe(data.dob);
    this.phoneNumber = normalizeMaybe(data.phoneNumber);
    this.profileImage = normalizeMaybe(data.profileImage);
    this.address = address;
    this.socialLinks = socialLinks;
  }
}
```

## !!steps Implementing Serialize Method  

Add the serialize method to convert the entity back to serialized format for external APIs, demonstrating the round-trip data transformation.

```typescript !
// !collapse(1:5) collapsed
// Collapsed imports
import { BaseEntity, IEntity } from "@domain/utils/base.entity";
import { UUID } from "@domain/utils/refined.types";
import { Address } from "./address.vo";
import { SocialLinks } from "./socialLinks.vo";
import { Option as O } from "effect";

// !collapse(1:3) collapsed
// Collapsed Maybe type definition
type Maybe<T> = T | O.Option<T> | null | undefined;

// !collapse(1:11) collapsed
// Collapsed normalizeMaybe utility
const normalizeMaybe = <T>(value: Maybe<T>): O.Option<T> => {
  if (value === null || value === undefined) {
    return O.none();
  }
  if (O.isOption(value)) {
    return value;
  }
  return O.some(value);
};

// !collapse(1:7) collapsed
// Collapsed SerializedHost type
type SerializedHost = {
  id: string; createdAt: string; updatedAt: string;
  userId: string; dob: Maybe<Date>; phoneNumber: Maybe<number>;
  profileImage: Maybe<string>; address: unknown; socialLinks: unknown;
}

// !collapse(1:7) collapsed
// Collapsed IHost
interface IHost extends IEntity {
  readonly userId: UUID;
  readonly dob: O.Option<Date>;
  readonly phoneNumber: O.Option<number>;
  readonly profileImage: O.Option<string>;
}

export class Host extends BaseEntity implements IHost {
  // !collapse(1:15) collapsed
  // Collapsed class properties and constructor
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;
  
  constructor(data: SerializedHost, address: Address, socialLinks: SocialLinks) {
    super();
    this._fromSerialized({id: data.id, createdAt: data.createdAt, updatedAt: data.updatedAt});
    this.userId = data.userId as UUID;
    this.dob = normalizeMaybe(data.dob);
    this.phoneNumber = normalizeMaybe(data.phoneNumber);
    this.profileImage = normalizeMaybe(data.profileImage);
    this.address = address; this.socialLinks = socialLinks;
  }
  
  // !mark(1:14) rgb(34, 197, 94)
  /**
   * Convert entity back to serialized format for external APIs
   */
  serialize(): SerializedHost {
    return {
      // Serialize base entity properties
      ...this._serialize(), // !info[/\.\.\.this\._serialize\(\)/] Includes base entity fields automatically
      // Convert host-specific fields
      userId: this.userId,
      dob: optionToMaybe(this.dob), // !callout[/optionToMaybe/] Converts Option<T> back to Maybe<T> for serialization
      phoneNumber: optionToMaybe(this.phoneNumber),
      profileImage: optionToMaybe(this.profileImage),
      // Serialize value objects
      address: this.address.serialize(), // !warning[/\.serialize\(\)/] Value objects must implement their own serialization
      socialLinks: this.socialLinks.serialize()
    };
  }
}
```

## !!steps Adding optionToMaybe Utility

Show the companion utility for converting Options back to Maybe types for serialization, completing the round-trip transformation.

```typescript !
// !collapse(1:5) collapsed
// Collapsed imports
import { BaseEntity, IEntity } from "@domain/utils/base.entity";
import { UUID } from "@domain/utils/refined.types";
import { Address } from "./address.vo";
import { SocialLinks } from "./socialLinks.vo";
import { Option as O } from "effect";

// !collapse(1:3) collapsed
// Collapsed Maybe type definition
type Maybe<T> = T | O.Option<T> | null | undefined;

// !collapse(1:11) collapsed
// Collapsed normalizeMaybe utility
const normalizeMaybe = <T>(value: Maybe<T>): O.Option<T> => {
  if (value === null || value === undefined) {
    return O.none();
  }
  if (O.isOption(value)) {
    return value;
  }
  return O.some(value);
};

// !mark(1:5) rgb(34, 197, 94)
/**
 * Convert an Option<T> value to Maybe<T> for serialization
 */
const optionToMaybe = <T>(option: O.Option<T>): Maybe<T> => {
  return O.getOrNull(option) as Maybe<T>; // !info[/O\.getOrNull/] Extracts value or returns null for external APIs
}; // !callout[/optionToMaybe/] Reverse transformation for serialization

// !collapse(1:30) collapsed
// Collapsed previous definitions
type SerializedHost = {
  id: string; createdAt: string; updatedAt: string;
  userId: string; dob: Maybe<Date>; phoneNumber: Maybe<number>;
  profileImage: Maybe<string>; address: unknown; socialLinks: unknown;
}

interface IHost extends IEntity {
  readonly userId: UUID;
  readonly dob: O.Option<Date>;
  readonly phoneNumber: O.Option<number>;
  readonly profileImage: O.Option<string>;
}

export class Host extends BaseEntity implements IHost {
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;
  
  constructor(data: SerializedHost, address: Address, socialLinks: SocialLinks) {
    super();
    this._fromSerialized({id: data.id, createdAt: data.createdAt, updatedAt: data.updatedAt});
    this.userId = data.userId as UUID;
    this.dob = normalizeMaybe(data.dob);
    this.phoneNumber = normalizeMaybe(data.phoneNumber);
    this.profileImage = normalizeMaybe(data.profileImage);
    this.address = address; this.socialLinks = socialLinks;
  }
  
  serialize(): SerializedHost {
    return {
      ...this._serialize(),
      userId: this.userId,
      dob: optionToMaybe(this.dob),
      phoneNumber: optionToMaybe(this.phoneNumber),
      profileImage: optionToMaybe(this.profileImage),
      address: this.address.serialize(),
      socialLinks: this.socialLinks.serialize()
    };
  }
}
```

## !!steps Adding Basic Guards to Class

Introduce validation guards directly in the class for data integrity and business rule enforcement.

```typescript !
// !collapse(1:20) collapsed
type Maybe<T> = T | O.Option<T> | null | undefined;
type SerializedHost = {
  id: string; createdAt: string; updatedAt: string;
  userId: string; dob: Maybe<Date>; phoneNumber: Maybe<number>;
  profileImage: Maybe<string>; address: unknown; socialLinks: unknown;
}

export class Host extends BaseEntity implements IHost {
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;
  
  constructor(data: SerializedHost, address: Address, socialLinks: SocialLinks) {
    super();
    this._fromSerialized({id: data.id, createdAt: data.createdAt, updatedAt: data.updatedAt});
    this.userId = data.userId as UUID;
    this.dob = normalizeMaybe(data.dob);
    this.phoneNumber = normalizeMaybe(data.phoneNumber);
    this.profileImage = normalizeMaybe(data.profileImage);
    this.address = address; this.socialLinks = socialLinks;
  }

  // !mark(1:12) rgb(34, 197, 94)
  private static validatePhoneNumber(phone: O.Option<number>): boolean {
    return O.match(phone, {
      onNone: () => true, // Optional field, none is valid
      onSome: (num) => num > 1000000000 && num < 9999999999
    });
  }
  
  private static validateDateOfBirth(dob: O.Option<Date>): boolean {
    return O.match(dob, {
      onNone: () => true,
      onSome: (date) => date < new Date() && date > new Date('1900-01-01')
    });
  }
}

// !callout[/O\.match/] Pattern matching on Option values
// !info[/onNone.*onSome/] Handle both empty and present cases
```

## !!steps Using Guards in Constructor

Integrate the guards into the constructor for safe entity creation with validation.

```typescript !
// !collapse(1:25) collapsed
export class Host extends BaseEntity implements IHost {
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;

  // !mark(1:16) rgb(34, 197, 94)
  constructor(data: SerializedHost, address: Address, socialLinks: SocialLinks) {
    super();
    this._fromSerialized({
      id: data.id,
      createdAt: data.createdAt,
      updatedAt: data.updatedAt
    });
    
    // Validate before assignment
    const normalizedDob = normalizeMaybe(data.dob);
    const normalizedPhone = normalizeMaybe(data.phoneNumber);
    
    if (!Host.validateDateOfBirth(normalizedDob)) {
      throw new Error('Invalid date of birth');
    }
    if (!Host.validatePhoneNumber(normalizedPhone)) {
      throw new Error('Invalid phone number');
    }
    
    this.userId = data.userId as UUID;
    this.dob = normalizedDob;
    this.phoneNumber = normalizedPhone;
    this.profileImage = normalizeMaybe(data.profileImage);
    this.address = address;
    this.socialLinks = socialLinks;
  }

  // !collapse(1:12) collapsed
  private static validatePhoneNumber(phone: O.Option<number>): boolean {
    return O.match(phone, {
      onNone: () => true,
      onSome: (num) => num > 1000000000 && num < 9999999999
    });
  }
  
  private static validateDateOfBirth(dob: O.Option<Date>): boolean {
    return O.match(dob, {
      onNone: () => true,
      onSome: (date) => date < new Date() && date > new Date('1900-01-01')
    });
  }
}

// !warning[/throw new Error/] Exception-based error handling to be improved
// !info[/Validate before assignment/] Guards prevent invalid state
```

## !!steps Making Constructor Private with Factory Method

Hide the constructor and provide a static factory method for controlled entity creation.

```typescript !
// !collapse(1:15) collapsed
type SerializedHost = {
  id: string; createdAt: string; updatedAt: string;
  userId: string; dob: Maybe<Date>; phoneNumber: Maybe<number>;
  profileImage: Maybe<string>; address: unknown; socialLinks: unknown;
}

export class Host extends BaseEntity implements IHost {
  // !collapse(1:6) collapsed
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;
  
  // !mark(1:1) rgb(234, 179, 8)
  private constructor(data: SerializedHost, address: Address, socialLinks: SocialLinks) {
    // Previous constructor implementation with validation
    super();
    this._fromSerialized({id: data.id, createdAt: data.createdAt, updatedAt: data.updatedAt});
    
    const normalizedDob = normalizeMaybe(data.dob);
    const normalizedPhone = normalizeMaybe(data.phoneNumber);
    
    if (!Host.validateDateOfBirth(normalizedDob)) {
      throw new Error('Invalid date of birth');
    }
    if (!Host.validatePhoneNumber(normalizedPhone)) {
      throw new Error('Invalid phone number');
    }
    
    this.userId = data.userId as UUID;
    this.dob = normalizedDob;
    this.phoneNumber = normalizedPhone;
    this.profileImage = normalizeMaybe(data.profileImage);
    this.address = address; this.socialLinks = socialLinks;
  }
  
  // !mark(1:8) rgb(34, 197, 94)
  static create(serialized: SerializedHost): Host {
    // Create value objects first
    const address = Address.create(serialized.address);
    const socialLinks = SocialLinks.create(serialized.socialLinks);
    
    // Validate and create host
    return new Host(serialized, address, socialLinks);
  }

  // !collapse(1:12) collapsed
  private static validatePhoneNumber(phone: O.Option<number>): boolean {
    return O.match(phone, {
      onNone: () => true,
      onSome: (num) => num > 1000000000 && num < 9999999999
    });
  }
  
  private static validateDateOfBirth(dob: O.Option<Date>): boolean {
    return O.match(dob, {
      onNone: () => true,
      onSome: (date) => date < new Date() && date > new Date('1900-01-01')
    });
  }
}

// !warning[/private constructor/] Prevents direct instantiation
// !callout[/static create/] Controlled entity creation through factory method
```

## !!steps Moving Guards to Separate File

Extract guards to a dedicated file for better organization and reusability across the domain.

```typescript !
// !mark(1:18) rgb(34, 197, 94)
// host.guards.ts
import { Option as O } from "effect";

export class HostGuards {
  static validatePhoneNumber(phone: O.Option<number>): boolean {
    return O.match(phone, {
      onNone: () => true, // !info[/onNone.*onSome/] Handle both empty and present cases
      onSome: (num) => num > 1000000000 && num < 9999999999
    }); // !callout[/O\.match/] Pattern matching on Option values
  }
  
  static validateDateOfBirth(dob: O.Option<Date>): boolean {
    return O.match(dob, {
      onNone: () => true,
      onSome: (date) => date < new Date() && date > new Date('1900-01-01')
    });
  }
} // !callout[/HostGuards/] Centralized validation logic for reusability across domain
```

## !!steps Using External Guards in Factory Method

Update the factory method to use the external guards with custom error types.

```typescript !
// !collapse(1:15) collapsed
import { HostGuards } from "./host.guards";
import { HostValidationError } from "./host.error";

export class Host extends BaseEntity implements IHost {
  userId: UUID;
  dob: O.Option<Date>;
  phoneNumber: O.Option<number>;
  profileImage: O.Option<string>;
  address: Address;
  socialLinks: SocialLinks;

  private constructor(data: SerializedHost, address: Address, socialLinks: SocialLinks) {
    // Simplified constructor without validation (moved to factory)
    super();
    this._fromSerialized({id: data.id, createdAt: data.createdAt, updatedAt: data.updatedAt});
    this.userId = data.userId as UUID;
    this.dob = normalizeMaybe(data.dob);
    this.phoneNumber = normalizeMaybe(data.phoneNumber);
    this.profileImage = normalizeMaybe(data.profileImage);
    this.address = address; this.socialLinks = socialLinks;
  }

  // !mark(1:14) rgb(34, 197, 94)
  static create(serialized: SerializedHost): Host {
    const address = Address.create(serialized.address);
    const socialLinks = SocialLinks.create(serialized.socialLinks);
    
    // Use external guards with proper error handling
    const normalizedDob = normalizeMaybe(serialized.dob);
    const normalizedPhone = normalizeMaybe(serialized.phoneNumber);
    
    if (!HostGuards.validateDateOfBirth(normalizedDob)) {
      throw new HostValidationError('Invalid date of birth');
    }
    if (!HostGuards.validatePhoneNumber(normalizedPhone)) {
      throw new HostValidationError('Invalid phone number');
    }
    
    return new Host(serialized, address, socialLinks);
  }
}

// !callout[/HostGuards\./] External guard usage
// !warning[/HostValidationError/] Custom error types for better error handling
```

## !!steps The Problem with Manual Encoding/Decoding

Highlight the complexity and repetition in current approach before introducing Effect Schema.

```typescript !
// !warning(1:20) Current approach has several issues
/*
‚ùå PROBLEMS WITH CURRENT APPROACH:

1. Manual serialization/deserialization is error-prone
2. Repetitive validation logic across entities  
3. Exception-based error handling
4. Type safety gaps between serialized and runtime types
5. Difficult to maintain as entity grows
6. No automatic derivation of types
7. Boilerplate code for every entity

Example of repetitive pattern:
*/
serialize(): SerializedHost {
  return {
    ...this._serialize(),
    userId: this.userId,
    dob: optionToMaybe(this.dob),           // Manual conversion
    phoneNumber: optionToMaybe(this.phoneNumber), // Manual conversion  
    profileImage: optionToMaybe(this.profileImage), // Manual conversion
    // ... more manual mappings for each field
  };
}

// !info[/Manual conversion/] Every field requires explicit transformation
// !warning[/Repetitive pattern/] Same pattern repeated for every entity
```

## !!steps Introducing Effect Schema

Show a simple example of Effect Schema's power for automatic encoding/decoding.

```typescript !
// !mark(1:1) rgb(34, 197, 94)
import { Schema as S } from "effect";

// !mark(1:12) rgb(34, 197, 94)
// Simple schema example
const PersonSchema = S.Struct({
  name: S.String,
  age: S.Number,
  email: S.optional(S.String)
});

// Automatic type derivation
type Person = S.Schema.Type<typeof PersonSchema>; // !callout[/S\.Schema\.Type/] Types automatically derived from schema
type SerializedPerson = S.Schema.Encoded<typeof PersonSchema>; // Same structure for simple types

// Automatic validation and transformation
const validatePerson = S.decodeUnknown(PersonSchema); // !info[/S\.decodeUnknown/] Automatic validation and transformation

// !warning[/Single source of truth/] Schema defines structure, types, and validation
```

## !!steps Creating Host Schema

Define the Host schema that will replace manual type definitions and validation.

```typescript !
// !mark(1:18) rgb(34, 197, 94)
import { StringToUUID, DateTimeFromAny } from "@domain/utils/refined.types";
import { Optional } from "@domain/utils/validation.utils";

const HostSchema = S.Struct({
  // Base entity fields
  id: StringToUUID,
  createdAt: DateTimeFromAny,
  updatedAt: DateTimeFromAny,
  
  // Host-specific fields
  userId: StringToUUID,
  dob: Optional(S.DateFromSelf),
  phoneNumber: Optional(S.Number),
  profileImage: Optional(S.String),
  
  // Value objects
  address: AddressSchema,
  socialLinks: SocialLinksSchema
});

// !callout[/Single schema definition/] One source of truth for structure
// !info[/Optional\(S\.DateFromSelf\)/] Built-in optional field handling
// !warning[/AddressSchema/] Composition with value object schemas
```

## !!steps Deriving Types from Schema

Show how types are automatically derived from the schema, eliminating manual type definitions.

```typescript !
// !collapse(1:15) collapsed
const HostSchema = S.Struct({
  id: StringToUUID,
  createdAt: DateTimeFromAny,
  updatedAt: DateTimeFromAny,
  userId: StringToUUID,
  dob: Optional(S.DateFromSelf),
  phoneNumber: Optional(S.Number),
  profileImage: Optional(S.String),
  address: AddressSchema,
  socialLinks: SocialLinksSchema
});

// !mark(1:8) rgb(34, 197, 94)
// Types automatically derived from schema
export type HostType = S.Schema.Type<typeof HostSchema>;
export type SerializedHost = Omit<S.Schema.Encoded<typeof HostSchema>, "address" | "socialLinks"> & {
  address: SerializedAddress;
  socialLinks: SerializedSocialLinks;
};

// No more manual type definitions needed!

// !callout[/HostType/] Runtime type with proper Option<T> handling
// !info[/SerializedHost/] Serialized type for external APIs
// !warning[/No more manual types/] Eliminates manual type definitions
```

## !!steps Integrating Guards into Schema

Show how simple validations can be moved directly into the schema as filters.

```typescript !
// !collapse(1:10) collapsed
import { HostGuards } from "./host.guards";

const HostSchema = S.Struct({
  id: StringToUUID,
  createdAt: DateTimeFromAny,
  updatedAt: DateTimeFromAny,
  userId: StringToUUID,
  
  // !mark(1:3) rgb(34, 197, 94)
  dob: Optional(S.DateFromSelf.pipe(HostGuards.ValidDateOfBirth)),
  phoneNumber: Optional(S.Number.pipe(HostGuards.ValidPhoneNumber)),
  profileImage: Optional(S.String.pipe(HostGuards.ValidProfileImagePath)),
  
  address: AddressSchema,
  socialLinks: SocialLinksSchema
});

// !callout[/\.pipe\(HostGuards\./] Validation logic integrated into schema
// !info[/Declarative validation/] Guards become part of schema definition
```

## !!steps Simplified Entity with Effect Schema

Show the final Host class that leverages Effect Schema for encoding/decoding.

```typescript !
// !collapse(1:15) collapsed
export const HostSchema = S.Struct({
  id: StringToUUID, createdAt: DateTimeFromAny, updatedAt: DateTimeFromAny,
  userId: StringToUUID, dob: Optional(S.DateFromSelf.pipe(HostGuards.ValidDateOfBirth)),
  phoneNumber: Optional(S.Number.pipe(HostGuards.ValidPhoneNumber)),
  profileImage: Optional(S.String.pipe(HostGuards.ValidProfileImagePath)),
  address: AddressSchema, socialLinks: SocialLinksSchema
});

export type HostType = S.Schema.Type<typeof HostSchema>;
export type SerializedHost = Omit<S.Schema.Encoded<typeof HostSchema>, "address" | "socialLinks"> & {
  address: SerializedAddress; socialLinks: SerializedSocialLinks;
};

export class Host extends BaseEntity implements IEntity {
  // !collapse(1:6) collapsed
  readonly userId: UUID;
  readonly dob: O.Option<Date>;
  readonly phoneNumber: O.Option<number>;
  readonly profileImage: O.Option<string>;  
  readonly address: Address;
  readonly socialLinks: SocialLinks;

  // !mark(1:18) rgb(34, 197, 94)
  private constructor(data: HostType, address: Address, socialLinks: SocialLinks) {
    super();
    this._fromSerialized({
      id: data.id,
      createdAt: data.createdAt, 
      updatedAt: data.updatedAt
    });
    
    // Direct assignment - no manual conversion needed
    this.userId = data.userId;
    this.dob = data.dob;
    this.phoneNumber = data.phoneNumber;
    this.profileImage = data.profileImage;
    this.address = address;
    this.socialLinks = socialLinks;
  }
}

// !callout[/HostType/] Uses schema-derived types
// !info[/Direct assignment/] No manual Option conversion needed
// !warning[/readonly/] Properties are now immutable
```

## !!steps Effect-Based Factory Method

Show the new factory method that uses Effect for error handling instead of exceptions.

```typescript !
// !collapse(1:10) collapsed
export class Host extends BaseEntity implements IEntity {
  readonly userId: UUID;
  readonly dob: O.Option<Date>;
  readonly phoneNumber: O.Option<number>;
  readonly profileImage: O.Option<string>;
  readonly address: Address;
  readonly socialLinks: SocialLinks;

  private constructor(data: HostType, address: Address, socialLinks: SocialLinks) {
    // Constructor implementation from previous step
  }

  // !mark(1:22) rgb(34, 197, 94)
  static create(input: SerializedHost): E.Effect<Host, HostError, never> {
    return pipe(
      S.decodeUnknown(HostSchema)(input),
      E.flatMap((data) => {
        // Domain validation
        return HostGuards.validateHostDomain({
          userId: data.userId,
          phoneNumber: data.phoneNumber,
          profileImage: data.profileImage
        }).pipe(
          E.flatMap(() => {
            // Create value objects
            return E.all([
              Address.create(input.address), 
              SocialLinks.create(input.socialLinks)
            ]).pipe(
              E.map(([address, socialLinks]) => 
                new Host(data, address, socialLinks))
            );
          })
        );
      }),
      E.mapError((error) => new HostValidationError("entity", input, error.message))
    );
  }
}

// !callout[/E\.Effect/] Effect-based error handling
// !info[/pipe/] Composable validation pipeline
// !warning[/No exceptions/] Functional error handling without try/catch
```

## !!steps Simplified Serialization

Show how serialization becomes trivial with Effect Schema.

```typescript !
// !collapse(1:25) collapsed
export class Host extends BaseEntity implements IEntity {
  readonly userId: UUID;
  readonly dob: O.Option<Date>;
  readonly phoneNumber: O.Option<number>;
  readonly profileImage: O.Option<string>;
  readonly address: Address;
  readonly socialLinks: SocialLinks;

  private constructor(data: HostType, address: Address, socialLinks: SocialLinks) {
    // Previous implementation
  }

  static create(input: SerializedHost): E.Effect<Host, HostError, never> {
    // Previous implementation
  }

  // !mark(1:3) rgb(34, 197, 94)
  serialized(): E.Effect<SerializedHost, ParseResult.ParseError, never> {
    return S.encode(HostSchema)(this);
  }

  // !mark(1:8) rgb(34, 197, 94)
  updateProfile(updates: SerializedHostUpdate): E.Effect<Host, HostError, never> {
    return this.serialized().pipe(
      E.flatMap((currentSerialized) => {
        const updatedData: SerializedHost = {
          ...currentSerialized,
          ...updates,
          updatedAt: new Date()
        };
        return Host.create(updatedData);
      })
    );
  }
}

// !callout[/S\.encode/] Automatic serialization with validation
// !info[/One-line serialization/] No manual field mapping required
// !warning[/updateProfile/] Immutable updates through recreation
```

</ScrollyCoding>

## Utilities Overview

### Base Entity (`base.entity.ts`)
Contains the `SimpleSerialized<T>` type utility for entity serialization.

### Refined Types (`refined.types.ts`)
Provides `Maybe<T>`, `normalizeMaybe`, and `optionToMaybe` utilities for handling optional values safely.