---
title: Headless Document Management System
description: Headless Document Management System
---

# Pre Requisites

## Kick-Off (Week 1)

### Tasks

Create a Document Management System (DMS) with basic CRUD operations for documents.

- Build endpoints for uploading documents with metadata.
  - Build endpoint for managing metadata.
  - Build endpoints for managing permissions.
- Introduce JWT-based authentication for securing endpoints.
- Build endpoint for generating short lived download links for files. 
- Implement advanced search filters for documents using tags and metadata.

Cover gitflow and prepare a custom diagram in figjam. Goal is to visualize SDLC from git flow perspective

### Expectations

* Implement roles and permissions for users (Admin, User) using role-based access control (RBAC).
* Prefer async-await over then and callbacks.
* Use [drizzle](https://orm.drizzle.team/) as an orm to work with databases.
* Don't rely on database generated Id and instead use application generated UUID.
* Validate every aspect of the input to the endpoints using [Zod](https://www.npmjs.com/package/zod).
* Use auth [middleware](https://refactoring.guru/design-patterns/chain-of-responsibility) in express to handle login.


<Aside type='caution' title='Note' >

In refactoring phases, review should occur at 4 day of weekly task to in-cooperate feedback from trainer. 

</Aside>

## Refactor Phase 1 (Week 2)

### Tasks

* Refactor the code to adapt following features from __12 Factor Apps__.
  * Codebase
  * Dependencies
  * [Config](https://www.npmjs.com/package/dotenv)
* Create services to move the logic away from controllers.
* Better understanding of __Monads__ and __Railway Pattern__  using intelligent exceptions messages.
* Abstract away ORM model and create a physical store like APIs using repository pattern with interface for stores and their concrete implementation utilizing ORM models.

  
<Aside type='tip' title='Principles At Play' >

**Independent of Database.** You can swap out Oracle or SQL Server, for Mongo, BigTable, CouchDB, or something else. Your business rules are not bound to the database.

</Aside>


* Create abstractions for the logging implementation in the system and use DI to inject appropriate loggers everywhere.

### Expectations

* Controllers will only be used for passing (clean/validated) and receiving data from services and should be as lean as possible.
* Use standard pagination options as input for pagination and paginatedCollections as output.
* Understand the above mentioned concepts of 12 factor apps.
* Make sure the store API's are similar to actual physical stores, 
* Use DI to inject repository interfaces directly in services.



## Refactor Phase 2 (Week 3)

### Tasks

* Extract and house all [entities](https://www.raywenderlich.com/books/real-world-android-by-tutorials/v1.0/chapters/3-domain-layer)__ in the platform in separate folder and utilize factory pattern (__static factory methods__ or factories to create entities)


<Aside type='tip' title='Principles At Play' >

**Independent of any external agency.** In fact your business rules simply don’t know anything at all about the outside world.


**Testable**. The business rules can be tested without the UI, Database, Web Server, or any other external element.

</Aside>

- Abstract away the login mechanism and use DI to inject appropriate auth handlers in the code.
- Cover next concepts in 12 factor app
  - Processes
  - Port binding
  - Concurrency


<Aside type='tip' title='Principles At Play' >

* **Shippable right from the beginning.** Being agile as the defacto for every tech company it's really important, We have to make sure we can use declarative formats for setup, so it's much easier to bring on new engineer.

</Aside>

### Expectations

* Separate Input validation from business rules validations. e.g 
  * When sending money, amount must always be a positive integer, and there always must be a receiver credit card number in a correct format;
  * Client cannot purchase a product that is out of stock;
  * Client's wallet cannot have less than 0 balance. 
* Entities should encapsulate all the operations which change their state and we should design them in a way where invariants don’t exist in the system  
* Make sure the repositories always receive and return entities.
* Understand various [creational patterns](https://refactoring.guru/design-patterns/creational-patterns) by the end of this phase.
* There should be separation of concerns between entry point into the app and bootstrapping the HTTP framework/libraries. Use commander to instantiate the express server.

## Refactor Phase 3 (Week 4)

### Tasks

* Your framework is not your application. Refactor the application to move all app related code to separate directory and create abstractions based on __layered architecture__ to manage code.


<Aside type='tip' title='Principles At Play' >

**Independent of UI.** The UI can change easily, without changing the rest of the system. A Web UI could be replaced with a console UI, for example, without changing the business rules.


**Independent of Frameworks.** Express/Koa is not your application. The architecture does not depend on the existence of some library of feature laden software. This allows you to use such frameworks as tools, rather than having to cram your system into their limited constraints.

</Aside>

* Create abstractions to send and receive data from your application services.
* Use Migrations and fakers to repopulate databases.

### Expectations

* Diff between entities and value objects.
* Diff between services in diff layers. // Domain Service, Application Service, Infrastructure Service
* Correct use and understanding of onion architecture and DI in layered architecture.
* Pre-populate the database with fake/seed data.


## Refactor Phase 4 (Week 5)

### Tasks

* Refactor code to fulfill guidelines enforced by Hex app to design systems.
* Use mocha, sinon and chai to add test cases to the app for domain layer.

### Expectations

* Correct usage of functional concurrent functional flow in the app.
* Correct usage of AppResult to transform data across boundaries.
* Using Zod and associated utils in hex app to generate types and their validations at domain layer.
* Understanding shared utils in the hexapp.
* Using various other hexapp utils to refactor the existing codebase.

## Refactor Phase 5 (Week 6)

### Tasks

* Refactor the app to use multiple document stores using [strategy pattern](https://refactoring.guru/design-patterns/strategy).
* Add Observability and Application performance monitoring by integrating with newrelic.
* Create a CLI tool for bulk downloading the data (folders) from document management system.


<Aside type='tip' title='Principles At Play' >

**Being Resilient.** In this new API economy, relying on 3rd party systems is inevitable, resilient means allow systems to work with failure, rather than against it.


**Scalable** Applications should scale right from the start, It doesn't necessarily mean we are optimizing for performance or efficiency. It means our apps are distributed system friendly by being stateless and developer friendly by being readable which affects how quickly we can onboard a new developer.

</Aside>

### Expectations
* Correct use of Retry and timeouts for resilience 
* Adding concurrency constraints on background process.
* Use sentry/new relic to observer performance of Application

## How to submit your work

Create a public repo on Github and push your code on it. then share the link back with the team.

